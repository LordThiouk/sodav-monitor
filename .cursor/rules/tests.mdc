---
description: RÃ¨gles pour les Tests Unitaires sur Cursor AI (sodav-monitor)
globs: *
---
### ğŸ” **1. Structure des Tests**
- Tous les tests doivent Ãªtre situÃ©s dans un dossier `backend/tests/`.
- Chaque fichier de test doit suivre le format `test_<nom_de_la_fonction>.py`.
- Utiliser `pytest` comme framework de test.
- Update docs/tests toujours aprÃ¨s avoir lancÃ© tests
- GÃ©rÃ© l'amÃ©lioration des tests un par un, focus sur un test jusqua le rÃ©soudre avant de continuer
- Focus sur one component at time
- fais les tests en suivant instructions dans docs
Le **meilleur choix dÃ©pend des objectifs des tests** :

### âœ… **Utiliser des Stations RÃ©elles** (RecommandÃ© pour les tests d'intÃ©gration)
**Avantages :**
- Teste le systÃ¨me en conditions rÃ©elles.
- VÃ©rifie la connexion rÃ©seau, la stabilitÃ© des flux, et la dÃ©tection rÃ©elle de musique.
- Permet de valider l'ensemble de l'algorithme (temps de jeu, empreinte, confidence).

**InconvÃ©nients :**
- Plus lent et dÃ©pend des stations disponibles.
- Risque d'erreurs dues Ã  des interruptions de flux.

---

### ğŸ­ **Utiliser des Mockups** (RecommandÃ© pour les tests unitaires)
**Avantages :**
- Rapide, ne dÃ©pend pas des flux en direct.
- Permet d'isoler et de tester des fonctions spÃ©cifiques sans interruption.
- Utile pour simuler des scÃ©narios complexes (erreurs de connexion, dÃ©tection Ã©chouÃ©e).

**InconvÃ©nients :**
- Ne garantit pas que le systÃ¨me fonctionne correctement en conditions rÃ©elles.

---

### ğŸš€ **Recommandation**
1. **Tests unitaires** â†’ Utilisez des **mockups** pour tester les fonctions isolÃ©es.  
2. **Tests d'intÃ©gration** â†’ Utilisez des **stations rÃ©elles** pour tester l'ensemble du systÃ¨me.  

Vous voulez que je vous aide Ã  configurer les deux types de tests ? ğŸ”§

---

### ğŸ”’ **2. RÃ¨gles GÃ©nÃ©rales**

1. **Nomination des Fonctions de Test**  
   Chaque fonction de test doit commencer par `test_`.

2. **Isolation des Tests**  
   - Chaque test doit Ãªtre indÃ©pendant.  
   - Utiliser des fixtures pour les configurations rÃ©pÃ©tÃ©es.

3. **Assertions**  
   - Utiliser des assertions claires pour valider les sorties :  
     - `assert actual == expected`  
     - `assert isinstance(obj, ClassType)`  

4. **Mocking**  
   - Utiliser `unittest.mock` pour simuler des appels API externes (ex. Audd, MusicBrainz).  
   - Simuler les connexions aux bases de donnÃ©es avec des fixtures.

---

### ğŸ¶ **3. Tests SpÃ©cifiques aux FonctionnalitÃ©s**

#### ğŸ§ **DÃ©tection Musicale**

- VÃ©rifier si le systÃ¨me diffÃ©rencie correctement entre `speech` et `music`.
- Tester la dÃ©tection locale :
  - Empreinte dÃ©tectÃ©e avec succÃ¨s.
  - Empreinte non dÃ©tectÃ©e (retourne `None`).

#### ğŸŒ **APIs Externes (Fallbacks)**

- MusicBrainz et Audd doivent Ãªtre appelÃ©s si la dÃ©tection locale Ã©choue.
- GÃ©rer les rÃ©ponses vides et les erreurs rÃ©seau.

#### ğŸ“Š **Mise Ã  jour des Statistiques**

- VÃ©rifier la mise Ã  jour des champs suivants :
  - `play_time` par station
  - `detection_count`
  - `last_detected`
  - `average_confidence`

#### ğŸ“ˆ **Rapports et Abonnements**

- GÃ©nÃ©ration correcte des rapports (`CSV`, 'XLSX', 'PDF').
- VÃ©rification de l'envoi d'emails automatiques.

#### ğŸ”’ **SÃ©curitÃ©**

- Tester la vÃ©rification des mots de passe pour les utilisateurs.
- VÃ©rifier que les tokens JWT expirÃ©s ne sont pas acceptÃ©s.

---

### ğŸ“‚ **4. Couverture des Logs**

- Tous les Ã©vÃ©nements critiques doivent Ãªtre enregistrÃ©s.
- VÃ©rifier que les erreurs de dÃ©tection sont loguÃ©es.

---

### ğŸ’¡ **5. CritÃ¨res de SuccÃ¨s**

- Taux de couverture minimum : 90%
- Tous les tests doivent passer avant le dÃ©ploiement
- IntÃ©gration continue (CI) avec vÃ©rification automatique des tests

---

PrÃªt Ã  implÃ©menter ces rÃ¨gles dans votre projet ? ğŸš€